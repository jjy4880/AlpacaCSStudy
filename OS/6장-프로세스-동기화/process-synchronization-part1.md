# 프로세스 동기화 Part 1

## 경쟁 상황 (Race Condition)

경쟁 상황이란 **동시에 여러 개의 프로세스가 동일한 자료에 접근하여 조작하고, 그 실행결과가 접근이 발생한 특정 순서에 의존하는 상황** 을 말한다. 운영체제는 여러 부분에서 자원을 조작하기 때문에 경쟁 상황은 빈번하게 발생할 수 밖에 없다. 특히나 다중코어 시스템과 다중 스레드 프로그래밍의 환경에서는 여러 스레드들이 자원을 공유할 가능성이 매우 높다.

이 문제를 해결하려면 한 순간에 하나의 프로세스만 공유하는 데이터를 조작하도록 보장해야 한다. 즉 프로세스들을 동기화할 필요가 있다.

## 임계 영역 (Critical Section)

각 프로세스는 임계 영역이라는 코드 부분을 포함하고 있고, 이 안에서 다른 프로세스와 공유하는 변수를 변경하거나 테이블을 변경하거나 파일을 쓰거나 하는 등의 작업을 수행한다. 이 때 중요한 사실은 **한 프로세스가 자신의 임계 영역에서 작업을 수행하는 동안에는 다른 프로세스가 이 영역에 들어갈 수 없다** 는 것이다.

임계 영역 문제를 해결하기 위한 해결안은 다음 세 가지 조건을 충족해야 한다.
1. 상호 배제 (mutual exclusion)  
  한 프로세스가 자기 임계 영역에서 실행된다면 다른 프로세스들은 그 임계 영역에서 실행될 수 없다.
2. 진행 (progress)  
  임계 영역에서 실행 중인 프로세스가 없고 진입하려는 프로세스들이 있다면, 이들 중에 진입시킬 프로세스를 선택하여 진입시켜야 한다. 이 선택은 무기한으로 연기되어서는 안된다.
3. 한정된 대기 (bounded waiting)  
  프로세스가 임계 영역에 진입하려는 요청을 한 뒤로 요청이 허용될 때까지 다른 프로세스들이 임계 영역에 진입하도록 허용하는 횟수에는 제한이 있어야 한다. 즉 어떤 프로세스가 기아 상태가 되는 것을 막아야 한다는 뜻.

프로세스들이 협력적으로 실행되도록 하기 위하여 프로세스들은 일반적으로 다음과 같은 구조로 설계된다.

```java
do {
  진입 영역 (entry section)
  임계 영역
  퇴출 영역 (exit section)
  나머지 영역 (remainder section)
} while (TRUE);
```

진입 영역이란 임계 영역으로의 진입 허가를 요청하는 코드 부분이다. 퇴출 영역이란 임계 영역 이후에 따라와 마무리 하는 영역을 말한다. 나머지 영역은 말 그대로 코드의 나머지 부분이다.


## 소프트웨어적 해결: 피터슨의 해결안 (Peterson's solution)

현대 컴퓨터 구조에서 피터슨의 해결안이 항상 올바르게 동작한다는 보장은 없다. 현대 컴퓨터 구조가 load와 store 같은 기본적인 기계어를 실행하는 방식이기 때문이다. 그렇지만 임계 영역을 해결하기 위한 좋은 시도로서 알고리즘적 설명을 제시하고, 해결안의 세 가지 요구 조건에 대하여 생각해 볼 수 있는 기회를 준다.

```java
do {
  flag[i] = TRUE;
  turn = j;
  while (flag[j] && turn == j);

  (임계 영역)

  flag[i] = FALSE;

  (나머지 영역)
} while (TRUE);
```

한계: busy waiting

## 하드웨어적 해결: 동기화 하드웨어

앞서 말하였듯이 현대 컴퓨터 구조에서 피터슨의 해결안이 항상 올바르게 동작한다는 보장이 없다. 대신 일반적으로 락(lock)이라는 간단한 도구를 통해 임계 영역 문제를 해결할 수 있다. 임계 영역이 락에 의해 보호되게 함으로써 임계 영역을 보호할 수 있다. 프로세스는 임계 영역에 진입하기 전에 반드시 락을 획득하고, 나올 때에는 락을 방출한다.

하드웨어적인 해결 방법은 동기화 변수인 `lock`이라는 변수를 두는 것에서 시작한다. 이 변수를 다음과 같이 `false`로 초기화한다.

```java
boolean lock = false;
```

이 방법이 피터슨의 해결안과 다른 점은 작업이 하드웨어적으로 atomic하게 수행될 수 있도록 지원한다는 것이다. 즉 다음 코드에서 TestAndSet이라는 메서드가 호출되었을 때, 작업이 수행되는 동안 CPU를 선점 당하지 않아 작업이 쪼개지지 않고 한 덩어리 째로 끝까지 수행되는 것이 보장된다는 의미이다.

```java
Boolean TestAndSet(boolean *target) {
  boolean rv = *target; // read
  * target = true; // write
  return rv;
}

do {
  while (TestAndSet(&lock)) // 락 획득

  (임계 영역)

  lock = FALSE; // 락 방출

  (나머지 영역)
} while (TRUE);
```

## 세마포 (semaphore)

Lock의 추상 자료형

하드웨어 기반의 해결책은 프로그래머가 사용하기에는 다소 복잡하다. 이러한 어려움을 극복하기 위해 세마포라는 동기화 도구를 이용할 수 있다. 세마포에는 두 가지가 있다.

Counting Semaphore
* 증감하는 정수형 변수, 총 자원의 개수
* 연산 P(S): 자원을 획득하는 과정, lock
* 연산 V(S): 자원을 반납하는 과정, unlock
* busy-wait: S 값이 0 이하라 자원 여분이 없어 기다리는 상태

Binary Semaphore (mutex)
* 값 1, 한 개만 들어갈 수 있다.
* busy-wait는 효율적이지 않다. (= spin lock, "while을 계속 돌면서 확인한다." CPU 낭비)
* 대신 block & wakeup 방식으로 해결! (= sleep lock, "lock이 있으면 sleep 시킨다.")
  * P(S): S.value--; if S.value < 0 block;
  * V(S): S.value++; if S.value <= 0 wakeup(P);
  * 즉 S.value는 실제 가용 자원 개수라기보다는 양수면 자원있다, 0 이하면 없다는 의미.

### 교착상태(Deadlock)와 기아(Starvation)

교착상태: 둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상. 여럿 얽혀있는 모양.

기아: indefinite blocking. (정의). 각각의 입장

7장 교착상태에서 자세히 다룸

----

#### References
* Operating System Concepts (8th Edition), Abraham Silberschatz, 홍릉과학출판사
* [[강의] 운영체제, 교수 반효경, 이화여자대학교, 2017 - KOCW](http://www.kocw.net/home/search/kemView.do?kemId=1226304)
